# 15. 엔터티와 인코딩
HTTP는 다음을 보장
- 객체는 올바르게 식별되므로(Content-Type 미디어 포맷과 Content-Language 헤더를 이용해서) 브라우저나 다른 클라이언트는 콘텐츠를 바르게 처리할 수 있다.
- 객체는 올바르게 압축이 풀릴 것이다(Content-Length와 Content-Encoding 헤더를 이용해서).
- 객체는 항상 최신이다(엔터티 검사기와 캐시 만료 제어를 이용해서).
- 사용자의 요구를 만족할 것이다(내용 협상을 위한 Accept 관련 헤더들에 기반하여).
- 네트워크 사이를 빠르고 효율적으로 이동할 것이다(범위 요청, 델타 인코딩, 그 외의 데이터 압축을 이용해서).
- 조작되지 않고 온전하게 도착할 것이다(전송 인코딩 헤더와 Content-MD5 체크섬을 이용해서).

이를 보장하기 위해 HTTP는 콘텐츠를 나르기 위한 잘 라벨링된 엔터티를 사용

## 15.1 메시지는 컨테이너, 엔터티는 화물
#### Cotent-Type
엔터티에 의해 전달된 객체의 종류
#### Content-Length
전달되는 메시지의 길이나 크기
#### Content-Language
전달되는 객체와 가장 잘 대응되는 자연어
#### Content-Encoding
객체 데이터에 대해 행해진 변형(압축 등)
#### Content-Location
요청 시점을 기준으로, 객체의 또 다른 위치
#### Content-Range
만약 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의
#### Content-MD5
엔터티 본문의 콘텐츠에 대한 체크섬
#### Last-Modified
서버에서 이 콘텐츠가 생성 혹은 수정된 날
#### Expires
이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각
#### ETag
이 인스턴스에 대한 고유한 검사기. 엄밀히 말해 ETag 헤더는 엔터티 헤더로 정의되어 있지는 않지만 엔터티와 관련된 많은 동작을 위해 중요한 헤더
#### Cache-Control
어떻게 이 문서가 캐시될 수 있는지에 대한 지시자. ETag와 마찬가지로 Cache-Control 헤더도 엔터티 헤더로 정의되어 있지는 않다

#### 15.1.1 엔터티 본문
엔터티 본문은 가공되지 않은 날 데이터에 불과하기 때문에 엔터티 헤더는 그 데이터의 의미에 대해 설명할 필요가 있음

ex. Content-Type 엔터티 헤더는 그 데이터(이미지, 텍스트 등)를 어떻게 해석해야 하는지 말해주며, Content-Encoding 엔터티 헤더는 우리에게 그 데이터가 압축되었거나 혹은 추가적인 인코딩이 되었는지 말해줌

엔터티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작

## 15.2 Content-Length: 엔터티의 길이
Content-Length 헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타냄

어떻게 인코딩되었든 상관없이 크기를 표현할 수 있음

Content-Length 헤더는 메시지를 청크 인코딩으로 전송하지 않는 이상, 엔터티 본문을 포함한 메시지에서는 필수적

서버 충돌로 인해 메시지가 잘렸는지 감지하고자 할 때와 지속 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요

### 15.2.1 잘림 검출
클라이언트는 메시지 잘림을 검출하기 위해 Content-Length를 필요로 함

메시지 잘림은 캐싱 프락시 서버에서 특히 취약하기 때문에 캐싱 프락시 서버는 명시적으로 Content-Length 헤더를 갖고 있지 않은 HTTP 본문은 보통 캐시하지 않음

### 15.2.2 잘못된 Content-Length
초창기 클라이언트들과 서버들 중 일부는 Content-Length의 계산과 관련된 잘 알려진 버그들을 갖고 있기 때문에, 몇몇 클라이언트, 서버, 프락시 들은 서버가 이러한 오작동을 했는지 탐지하고 교정을 시도

공식적으로 HTTP/1.1 사용자 에이전트는 잘못된 길이를 받고 그 사실을 인지했을 때 사용자에게 알려주게 되어 있다

### 15.2.3 Content-Length와 지속 커넥션(Persistent Connection)
Content-Length는 지속 커넥션을 위해 필수이며, 만약 응답이 지속 커넥션을 통해서 온 것이라면, 또 다른 HTTP 응답이 즉시 그 뒤를 이을 것임

Content-Length 헤더는 클라이언트에게 메시지 하나가 어디서 끝나고 다음 시작은 어디인지 알려줌

커넥션이 지속적이기 때문에, 클라이언트가 커넥션이 닫힌 위치를 근거로 메시지의 끝을 인식하는 것은 불가능

HTTP 애플리케이션은 Content-Length 헤더 없이는 어디까지가 다음 메시지인지 알 수 없음

데이터를 각각이 특정한 크기를 갖는 일련의 청크들로 쪼개어 보내는 청크 인코딩을 사용하는 경우, 서버가 헤더가 생성되는 시점에서 엔터티 전체의 크기를 알 수 없다하더라도 서버는 청크 인코딩을 이용해 엔터티를 잘 정의된 크기의 조각들로 전송 가능

### 15.2.4 콘텐츠 인코딩
HTTP는 보안을 강화하거나 압축을 통해 공간을 절약할 수 있도록, 엔터티 본문을 인코딩할 수 있게 해줌

본문의 콘텐츠가 인코딩되어 있다면, Content-Length 헤더는 인코딩되지 않은 원본의 길이가 아닌 인코딩된 본문의 길이를 바이트 단위로 정의

### 15.2.5 엔터티 본문 길이 판별을 위한 규칙
1. 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP 메시지에서는, 본문 계산을 위한 Content-Length 헤더가 무시된다.
2. 메시지가 Transfer-Encoding 헤더를 포함하고 있다면, 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 '0 바이트 청크'라 불리는 특별한 패턴으로 끝나야 한다.
3. 메시지가 Content-Length 헤더를 갖는다면, Transfer-Encoding 헤더가 존재하지 않는 이상 Content-Length 값은 본문의 길이를 담게 된다.
4. 메시지가 'multipart/byteranges' 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면, 멀티파트 메시지의 각 부분은 각자가 스스로의 크기를 정의할 것이다.
5. 위의 어떤 규칙에도 해당되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝난다.
6. HTTP/1.0 애플리케이션과의 호환을 위해, 엔터티 본문을 갖고 있는 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더도 갖고 있어야 한다.

## 15.3 엔터티 요약
HTTP가 일반적으로 TCP/IP와 같이 신뢰할 만한 전송 프로토콜 위에서 구현됨에도 불구하고, 불완전한 트랜스코딩 프락시나 버그 많은 중개자 프락시를 비롯한 여러가지 이유로 메시지의 일부분이 전송 중에 변형되는 일이 일어남

엔터티 본문 데이터에 대한 의도하지 않은 변경을 감지하기 위해, 최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬을 생성할 수 있으며, 수신자는 모든 의도하지 않은 엔터티의 변경을 잡아내기 위해 그 체크섬으로 기본적인 검사를 할 수 있음

## 15.4 미디어 타입과 차셋(Charset)
Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술
|미디어 타입|설명|
|:--:|:--:|
|text/html|엔터티 본문은 HTML 문서|
|text/plain|엔터티 본문은 플레인 텍스트 문서|
|image/gif|엔터티 본문은 GIF 이미지|
|image/jpeg|엔터티 본문은 JPEG 이미지|
|audio/x-wav|엔터티 본문은 WAV 음향 데이터를 포함|
|model/vml|엔터티 본문은 삼차원 VRML 모델|
|application/vnd.ms-powerpoint|엔터티 본문은 마이크로소프트 파워포인트 프레젠테이션|
|multipart/byteranges|엔터티 본문은 여러 부분으로 나뉘는데, 각 부분은 전체 문서의 특정 범위(바이트 단위)를 담고 있다|
|message/http|엔터티 본문은 완전한 HTTP 메시지를 담고 있다|

### 15.4.1 텍스트 매체를 위한 문자 인코딩
Content-Type 헤더는 내용 유형을 더 자세히 지정하기 위한 선택적인 매개변수도 지원

ex. 엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 'charset' 매개변수

### 15.4.2 멀티파트 미디어 타입
MIME 멀티파일 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내짐

각 구성요소는 자족적으로 자신에 대해 서술하는 헤더를 포함

### 15.4.3 멀티파트 폼 제출
HTTP 폼을 채워서 제출하면, 가변 길이 텍스트 필드와 업로드 될 객체는 각각이 멀티파트 본문을 구성하는 하나의 파트가 되어 보내짐

멀티파트 본문은 여러 다른 종류와 길이의 값으로 채워진 폼을 허용

### 15.4.4 멀티파트 범위 응답
범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수 있음

그러한 응답은 Content-Type: multipart/byteranges 헤더 및 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 옴

## 15.5 콘텐츠 인코딩
HTTP 애플리케이션은 때때로 콘텐츠를 보내기 전에 인코딩을 하려고 함

ex. 느린 속도로 연결된 클라이언트에게 큰 HTML 문서를 전송하기 전에 서버는 전송 시간을 줄이기 위해 압축을 할 수 있음

서버는 허가받지 않은 제삼자가 볼 수 없도록 콘텐츠를 암호화하거나 뒤섞어서 보낼 수도 있음

### 15.5.1 콘텐츠 인코딩 과정
1. 웹 서버가 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성한다.
2. 콘텐츠 인코딩 서버가 인코딩된 메시지를 생성한다. 인코딩된 메시지는 Content-Type은 같지만 Content-Length는 다르다. 콘텐츠 인코딩 서버는 Content-Encoding 헤더를 인코딩된 메시지에 추가하여, 수신 측 애플리케이션이 그것을 디코딩할 수 있도록 한다.
3. 수신 측 프로그램은 인코딩된 메시지를 받아서 디코딩하고 원본을 얻는다.

### 15.5.2 콘텐츠 인코딩 유형
|콘텐츠 인코딩 값|설명|
|:--:|:--:|
|gzip|엔터티에 GNU zip 인코딩이 적용되었음을 의미한다|
|compress|엔터티에 대해 유닉스 파일 압축 프로그램인 'compress'가 실행되었음을 의미한다|
|deflate|엔터티가 zlib 포맷으로 압축되었음을 의미한다|
|identity|엔터티에 어떤 인코딩도 수행되지 않았음을 의미한다. Content-Encoding 헤더가 존재하지 않는다면 이 값인 것으로 간주한다|

### 15.5.3 Accept-Encoding 헤더
서버에서 클라이언트가 지원하지 않는 인코딩을 사용하는 것을 막기 위해, 클라이언트는 자신이 지원하는 인코딩의 목록을 Accept-Encoding 요청 헤더를 통해 전

만약 HTTP 요청에 Accept-Encoding 헤더를 포함하지 않는다면, 서버는 클라이언트가 어떤 인코딩이든 받아들일 수 있는 것으로 간주
## 15.6 전송 인코딩과 청크 인코딩
### 15.6.1 안전한 전송
#### 알 수 없는 크기
몇몇 게이트웨이 애플리케이션과 콘텐츠 인코더는 콘텐츠를 먼저 생성하지 않고서는 메시지 본문의 최종 크기를 판단할 수 없다
#### 보안
공용 전송 네트워크로 메시지 콘텐츠를 보내기 전에 전송 인코딩을 사용해 알아보기 어렵게 뒤섞어버릴 수 있으나, 이미 SSL과 같은 유명한 전송 계층 보안 방식이 있기 때문에 전송 인코딩 보안은 흔하지 않음
### 15.6.2 Transfer-Encoding 헤더
#### Transfer-Encoding
안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려줌
### TE
어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용
### 15.6.3 청크 인코딩
청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼개고, 서버는 각 청크를 순차적으로 보냄
#### 청크와 지속 커넥션
#### 청크 인코딩된 메시지의 트레일러
### 15.6.4 콘텐츠와 전송 인코딩의 조합
### 15.6.5 전송 인코딩 규칙
## 15.7 시간에 따라 바뀌는 인스턴스
## 15.8 검사기와 신선도
### 15.8.1 신선도
### 15.8.2 조건부 요청과 검사기
## 15.9 범위 요청
## 15.10 델타 인코딩
### 15.10.1 인스턴스 조작, 델타 생성기 그리고 델타 적용기
## 15.11 추가 정보
