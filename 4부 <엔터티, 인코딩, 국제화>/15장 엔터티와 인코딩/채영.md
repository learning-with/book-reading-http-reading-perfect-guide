# 15 엔터티, 인코딩, 국제화

HTTP가 보장하는 것

- 객체는 올바르게 식별되므로 Content-Type 미디어 포맷과 Content-Language 헤더를 이용해서 브라우저나 다른 클라이언트는 콘텐츠를 바르게 처리할 수 있음
- 객체는 올바르게 압축이 풀릴 것이다.
- 객체는 항상 최신이다.
- 사용자의 요구를 만족할 것이다
- 사용자의 요구를 만족할 것이다
- 네트워크 사이를 빠르게 효율적으로 이동할 것이다.
- 조작되지 않고 온전하게 도착할 것이다

## 15.1 메시지는 컨테이너, 엔터티는 화물

헤더필드와 본문은 CRLF(빈 줄)로 구분함.

> 10가지 주요 엔터티 헤더 필드의 정의

- Content-Type
- Content-Length
- Content-Language
- Content-Location
- Content-Range
- Content-MD5
- Last-Modified
- Expires
- Allow
- ETag
- Cache-Control

### 15.1.1 엔터티 본문

가공되지 않은 데이터만을 담고 있음.
Content-Type과 같은 엔터티 헤더로 데이터의 의미나 압축, 추가적인 인코딩 유무를 알려줌.

## 15.2 Content-Length :엔터티의 길이

메시지의 엔터티 본문의 크기를 바이트 단위로 나타냄.
어떻게 인코딩 되었든 상관없이 크기를 표현할 수 있음.메시지를 청크 인코딩으로 전송하지 않는 이상, 엔터티 본문을 포함한 메시지에서는 필수적으로 있어야함. 서버 충돌로 인해 메시지가 잘렸는지 감지하고자 할 때와 지속 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요.

### 15.2.1 잘림 검출

클라이언트는 메시지 잘림을 검출하기 위해 Content-Length를 필요로함. 메시지 잘림은 캐싱 프락시 서버에서 특히 취약. 잘린 메시지를 캐시하는 위험을 줄이기 위해, 캐싱 프락시 서버는 명시적으로 Content-Length 헤더를 갖고 있지 않은 HTTP본문은 보통 캐시하지 않음.

### 15.2.2 잘못된 Content-Length

잘못된 값을 담고 있을 경우 아예 빠진 것보다도 큰 피해를 유발할 수 있음.
초창기 클라이언트들과 서버들 중 일부는 Content-Length의 계산과 관련된 잘 알려진 버그들을 갖고 있기에, 몇몇 클라이언트, 서버, 프락시 들은 서버가 이러한 오동작을 했는지 탐지하고 교정을 시도함. HTTP/1.1사용자 에이전트는 잘못된 길이를 받아 인지했을 경우 사용자에게 알려줌.

### 15.2.3 Content-Length와 지속 커넥션(Persist Connection)

Content-Length는 지속 커넥션을 위해 필수! 커넥션은 지속적이기 때문에, 클라이언트가 커넥션이 닫힌 위치를 근거로 메시지의 끝은 인식하기는 불가능. Content-Length는 메시지 하나의 끝과 시작을 클라이언트에게 알려줌.

### 15.2.4 콘텐츠 인코딩

콘텐츠가 인코딩 되어있다면 Content-Length는 인코딩되지 않은 원본의 길이가 아닌 바이트 단위로 정의함. 잘못해서 인코딩 전의 크기를 보낼 경우 지속 커넥션일 때 심각한 오류 유발. 또한 인코딩 전의 크기로 보낼 시 클라이언트가 자신이 수행한 디코딩 과정 문제 검증을 어렵게 만듬.

### 15.2.5 엔터티 본문 길이 판별을 위한 규칙

규칙은 나열된 순서대로 적용돼야함.

## 15.3 엔터티 요약

엔터티 본문 데이터에 대한 의도치 않은 변경을 감지하기 위해 최초 엔터티가 생성될 시 송신자는 데이터에 대한 체크섬 생성 가능, 수신자는 모든 의도치 않은 엔터티의 변경을 잡아내기 위해 그 체크섬으로 기본적인 검사를 할 수 있음.

## 15.4 미디어 타입과 차셋(Charset)

Content-Type헤더 필드는 엔터티 본문의 MIME타입 (전달되는 데이터 매체의 기저 형식의 표준화된 이름)을 기술함.
|미디어 타입|엔터티 본문 설명|
|----|---|
|text/html|HTML 문서|
|text/plain|플레인 텍스트 문서|
|image/gif(jpeg)|GIF(JPEG)이미지|
|audio/x-wav|WAV 음향 데이터를 포함|
|model/vrml|엔터티 본문은 삼차원 VRML모델|
|application/vnd.ms-powerpoint|마이크로소프트 파워포인트 프레젠테이션|
|multipart/byteranges|여러 부분으로 나뉘는데, 각 부분은 전체 문서의 특정 범위 (바이트 단위)를 담고 있음|
|message/http|완전한 HTTP 메시지를 담고 있음|

원본 엔터티 본문의 미디어 타입을 명시하는 것은 중요함. 엔터티가 콘텐츠 인코딩을 거친 경우에도 Content-Type헤더 필드는 인코딩 전의 엔터티 본문 유형을 명시함.

### 15.4.1 텍스트 매체를 위한 문자 인코딩

charset이 매개변수의 예시

```
Content-Type: text/html; charset=iso-8859-4
```

### 15.4.2 멀티파트 미디어 타입

`MIME 멀티파트`이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함한 하나의 복합 메시지.

### 15.4.3 멀티파트 폼 제출

HTTP 폼을 채워서 제출하면, 가변 길이 텍스트 필드와 업로드 될 객체는 각각이 멀티파트 본문을 구성하는 하나의 파트가 되어 보내짐.

### 15.4.4 멀티파트 범위 응답

범위 요청에 대한 HTTP 응답도 멀티파트가 될 수 있음.

## 15.5 콘텐츠 인코딩

암호화류의 인코딩은 발송하는 쪽에서 콘텐츠에 적용함. 콘텐츠 인코딩이 끝난 데이터는 엔터티 본문에 담아 수신자에게 보냄.

### 15.5.1 콘텐츠 인코딩 과정

1. 웹서버가 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성.
2. 콘텐츠 인코딩 서버가 인코딩된 메시지를 생성함. 인토딩된 메시지는 Content-Type은 같지만 Content-Length는 다름. 콘텐츠 인코딩 서버는 Content-Encoding 헤더를 인코딩된 메시지를 추가하여 수신 측 애플리케이션이 그것을 디코딩할 수 있도록 함.
3. 수신 측 프로그램은 인코딩된 메시지를 받아서 디코딩하여 원본을 얻음.

### 15.5.2 콘텐츠 인코딩 유형

인코딩은 각 콘텐츠 인코딩 알고리즘에 고유한 토큰을 할당하는 IANA를 통해 표준화됨.
Content-Encoding 헤더는 이러한 표준화된 토큰값을 이용해 인코딩에 사용된 알고리즘들에 대해 기술함.
|콘텐츠 인코딩 값|엔터티에 적용 및 실행된 유형 설명|
|-----|----|
|gzip| GNU zip인코딩이 적용되었음을 의미.|
|compress|유닉스 파일 압축 프로그램인 compress가 실행되었음을 의미|
|deflate|zlib 포맷으로 압축되었음을 의미|
|identity|어떤 인코딩도 수행되지 않았음을 의미, Content-Encoding 헤더가 존재하지 않는다면 이 값으로 추정.|

### 15.5.3 Accept-Encoding 헤더

클라이언트는 자신이 지원하는 인코딩 목록을 Accept-Encoding 요청을 헤더를 통해 전달.Q갑을 매개변수로 더해 선호도를 나타낼 수 있음.

## 15.6 전송 인코딩과 청크 인코딩

text 파일은 gzip으로 압축하지만 JPEG 파일은 그렇게 하지 않음. 콘텐츠 코딩을 콘텐츠 포맷과 긴밀하게 연관됨. 전송 인코딩 또한 엔터티 본문에 적용되는 가역적 변환이지만, 구조적인 이유 때문에 이렇게 적용됨. 콘텐츠 포맷과는 독립적임.

### 15.6.1 안전한 전송

HTTP에서 전송된 메시지의 본문이 문제를 일으킬 수 있는 이유.

1. 알 수 없는 크기
2. 보안

### 15.6.2 Transfer-Encoding 헤더

`Transfer-Encoding`,`TE` 전송 인코딩을 제어하고 서술하기 위해 정의 된 헤더

- `Transfer-Encoding` 안전한 전송을 위해 어떤 인코딩이 적용됐는지 수신자에게 알려줌.
- `TE` 어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더를 사용함.

### 15.6.3 청크 인코딩

전송 인코딩의 한 형태이며 본문이 아닌 메시지의 속성임.

#### 청크와 지속 커넥션

서버가 본문을 여러 청크로 쪼개 보낼 수 있게 해줌으로써 지속커넥션이 가능하도록 함.

### 15.6.4 콘텐츠와 전송 인코딩의 조합

콘텐츠 인코딩을 사용해 HTML파일을 압축하고 청크 데이터를 전송 인코딩을 사용해서 전송하는 예시를 들 수 있음.

### 15.6.5 전송 인코딩 규칙

## 15.7 시간에 따라 바뀌는 인스턴스

## 15.8 검사기와 신선도

### 15.8.1 신선도

### 15.8.2 조건부 요청과 검사기

## 15.9 범위 요청

## 15.10 델타 인코딩

### 15.10.1 인스턴스 조작, 델타 생성기 그리고 델타 적용기

## 15.11 추가 정보
