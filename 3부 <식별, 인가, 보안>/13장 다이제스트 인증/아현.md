# 13. 다이제스트 인증
기본 인증은 편리하고 유연하지만 안전하지 않기 때문에 안전한 대체재로서 개발됨
## 13.1 다이제스트 인증의 개선점
- 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않는다
- 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단한다
- 구현하기에 따라서, 메시지 내용 위조를 막는 것도 가능하다
- 그 외 몇몇 잘 알려진 형태의 공격을 막는다

다이제스트 인증이 가장 안전한 프로토콜은 아니며, 안전한 HTTP 트랜잭션을 위한 많은 요구사항을 만족하지 못해 전송 계층 보안(TLS)과 보안 HTTP(HTTPS)가 더 적합한 프로토콜
### 13.1.1 비밀번호를 안전하게 지키기 위해 요약 사용하기
1. 클라이언트가 보호된 문서를 요구한다.
2. 서버는 클라이언트가 비밀번호를 알고 있음을 스스로 증명하여 신원을 인증하기 전까지 문서를 제공하기를 거부한다. 서버는 클라이언트에게 사용자 이름과 요약된 형태의 비밀번호를 요구한다.
3. 클라이언트는 비밀번호의 요약을 전달하여 자신이 비밀번호를 알고 있음을 증명한다. 서버는 모든 사용자의 비밀번호를 알고 있으므로, 클라이언트가 제공한 요약과 서버가 스스로 계산한 요약이 일치하는지 비교하여 사용자가 비밀번호를 알고 있는지 확인할 수 있다. 비밀번호를 모르는 사람은 올바른 요약을 만들어내기 쉽지 않을 것이다.
4. 서버는 클라이언트가 제공한 요약과 서버가 내부적으로 계산한 요약을 비교한다. 일치하면 이는 클라이언트가 비밀번호를 알고 있는 것이다. 이 요약 함수는 매우 긴 자릿수의 숫자를 만들어낼 수 있도록 되어 있기 때문에 사실상 찍어서 맞추는 것은 불가능하다. 서버가 일치 여부를 확인하면, 클라이언트에게 문서가 제공된다. 이 모든 과정에서 비밀번호는 결코 네트워크를 통해 전송되지 않는다.
### 13.1.2 단방향 요약
요약은 단방향 함수로 동작하고, 일반적으로 입력 가능한 무한 가지의 모든 입력값들을 유한한 범위의 압축으로 변환

요약 함수는 보통 암호 체크섬(cryptographic checksums)으로 불리며, 단방향 해시 함수이거나 지문 함수(fingerprint function)

### 13.1.3 재전송 방지를 위한 난스(nonce) 사용
단방향 요약은 비밀번호를 그대로 전송해야 할 필요성에서 해방시켜주며, 비밀번호에 대한 요약을 보내주고, 요약에서 원래 비밀번호를 해독할 수 없음을 보장받으면 됨

그러나 요약을 가로채서 재전송할 수 있기 때문에, 난스를 활용

난스를 비밀번호에 섞으면 난스가 바뀔 때마다 요약도 바뀌기 때문에 재전송 공격을 막아줌

다이제스트 인증은 난스를 사용할 것을 요구하며, 난스는 WWW-Authenticate 인증요구에 담겨서 서버에서 클라이언트로 넘겨짐 

### 13.1.4 다이제스트 인증 핸드셰이크
HTTP 다이제스트 인증 프로토콜은 기본 인증에서 사용하는 것과 비슷한 헤더를 사용하는, 강화된 버전의 인증

기존 헤더에 몇몇 새 옵션이 추가되었고, 선택적인 헤더는 Authorization-Info가 새로 추가됨

1. 1단계에서 서버는 서버는 난스 값을 계산한다. 2단계에서 서버는 난스를 WWW-Authenticate 인증요구 메시지에 담아, 서버가 지원하는 알고리즘 목록과 함께 클라이언트에 전송한다.
2. 3단계에서 클라이언트는 알고리즘을 선택하고 비밀번호와 그 외 데이터에 대한 요약을 계산한다. 4단계에서 클라이언트는 Authorization 메시지에 요약을 담아 서버에게 돌려준다. 만약 클라이언트가 서버를 인증하길 원한다면 클라이언트 난스를 보낼 수 있다.
3. 5단계에서 서버는 요약, 선택한 알고리즘, 그 외 보조 데이터들을 받고, 클라이언트가 했던 그대로 요약을 계산한다. 서버는 그 다음 자신이 계산한 요약과 네트워크로 전송되어 온 요약이 서로 같은지 확인한다. 만약 클라이언트가 대칭적으로 서버에게 클라이언트 난스를 갖고 인증을 요구했다면,클라이언트 요약이 만들어진다. 또한 서버는 클라이언트가 미리 다음번 요약을 올바르게 생성할 수 있도록 다음번 난스를 미리 계산해서 클라이언트에게 넘겨줄 수도 있다.
## 13.2 요약 계산
다이제스트 인증의 핵심은 공개된 정보, 비밀 정보, 시한부 난스 값을 조합한 단방향 요약
### 13.2.1 요약 알고리즘 입력 데이터
요약은 다음의 세 요소로부터 계산됨
- 단반향 해시 함수 H(d)와 요약 함수 KD(s,d). 여기서 s는 secret, d는 data를 의미
- 비밀번호 등 보안 정보를 담고 있는 데이터 덩어리.
- 요청 메시지의 비밀이 아닌 속성을 담고 있는 데이터 덩어리
### 13.2.2 H(d)와 KD(s,d) 알고리즘
다이제스트 인증은 여러 가지 요약 알고리즘을 선택할 수 있도록 지원

RFC2617에서 MD5와 MD5-sess를 제안하였으며, MD5가 기본값

MD5와 MD5-sess 어느 것을 사용하든 H 함수는 데이터의 MD5를 계산하고, KD 요약 함수는 콜론으로 연결된 비밀 데이터와 일반 데이터의 MD5를 계산

H(<데이터>) = MD5(<데이터>)

KD(<비밀>,<데이터>) = H(연결(<비밀>:<데이터>))

### 13.2.3 보안 관련 데이터(A1)
사용자 이름, 비밀번호, 보호 영역, 난스와 같은 비밀 보호 정보로 이루어져 있으며 메시지 자체가 아닌 비밀 번호와만 관련있음

#### MD5
모든 요청마다 단방향 해시를 실행한다. A1은 사용자 이름, 영역, 비밀번호를 콜론으로 연결한 것이다.
#### MD5-sess
사용자 이름, 영역, 비밀번호에 대한 해시를 계산한 결과 뒤에 현재 난스와 클라이언트 난스(c난스)를 붙인 것이 A1이 된다. CPU를 많이 사용하는 해시 계산은 처음 WWW-Authenticate 핸드셰이크를 할 때 단 한 번만 수행된다.

### 13.2.4 메시지 관련 데이터(A2)
URL, 요청 메서드, 메시지 엔터티 본문과 같은 메시지 자체의 정보를 나타내며, 메서드, 리소스, 메시지의 위조를 방지하기 위해 사용됨

RFC 2617은 선택된 보호 수준(quality of protection, qop)에 따른 A2의 두 가지 사용법을 정의
- HTTP 요청 메서드와 URL만 포함하는 것이다. 이것은 기본값이기도 한 qop="auth"일 때 사용된다.
- 메시지 무결성 검사를 제공하기 위해 메시지 엔터티 본문을 추가하는 것이다. 이것은 qop="auth-int"일 때 사용된다.

|qop|A2|
|:--:|:--:|
|정의되지 않음|<요청 메서드>:<uri 지시자 값>|
|auth|<요청 메서드>:<uri 지시자 값>|
|auth-int|<요청 메서드>:<uri 지시자 값>:H(<요청 엔터티 본문>)|
### 13.2.5 요약 알고리즘 전반
RFC 2617은 주어진 H, KD, A1, A2로 요약을 계산하는 두가지 방법을 정의
- 예전 명세인 RFC 2069와 호환을 염두해 둔 것으로, qop 옵션이 빠졌을 때 사용된다. 비밀 정보와 난스가 붙은 메시지 데이터의 해시를 이용해 요약을 계산한다.
- 현대적이면서 보다 선호되는 접근법으로 난스 횟수 집계 및 대칭 인증의 지원을 포함한다. 이 접근법은 qop가 'auth'일 때와 'auth-int'일 때 모두 사용된다. 이것은 난스 횟수, qop, c난스 데이터를 요약에 추가한다.
### 13.2.6 다이제스트 인증 세션
### 13.2.7 사전(preemptive) 인가
#### 다음 난스 미리 생성하기
#### 제한된 난스 재사용
#### 동기화된 난스 생성
### 13.2.8 난스 선택
### 13.2.9 상호 인증
## 13.3 보호 수준(Quality of Protection) 향상
### 13.3.1 메시지 무결성 보호
### 13.3.2 다이제스트 인증 헤더
## 13.4 실제 상황에 대한 고려
### 13.4.1 다중 인증요구
### 13.4.2 오류 처리
### 13.4.3 보호 공간(Protection Space)
### 13.4.4 URI 다시 쓰기
### 13.4.5 캐시
## 13.5 보안에 대한 고려사항
### 13.5.1 헤더 부당 변경
헤더 부당 변경에 대해 항상 안전한 시스템을 제공하기 위해서, 양 종단 암호화나 헤더에 대한 디지털 서명이 필요할 것이다. 다이제스트 인증은 쉽게 조작할 수 없는 인증 제도를 제공하는 것에 초점을 맞추고 있으나 반드시 그 보호를 데이터에까지 확장하는 것은 아니다. 보호 수준에 대한 정보는 WWW-Authenticate와 Authorization 헤더에만 담겨있다.
### 13.5.2 재전송 공격
매 트랜잭션마다 유일한 난스 값을 사용하면 서버는 유일한 난스를 타임아웃 값과 함께 발급하여 발급된 난스 값은 그때의 트랜잭션과 주어진 타임아웃 값의 기간 동안만 유효하다. 이 계산이 서버에 부하를 가중시킬 수도 있으나 사소한 수준일 것이다.
### 13.5.3 다중 인증 메커니즘
클라이언트가 언제나 가능한 가장 강력한 인증 제도를 선택하거나, 가장 강력한 인증 제도만을 유지하는 프락시 서버를 사용한다.
### 13.5.4 사전(dictionary) 공격
악의적인 사용자는 트랜잭션을 엿들을 수 있고 난스/응답 쌍에 대해 흔히 구할 수 있는 비밀번호 추측 프로그램을 사용하거나, 사용자가 단순한 비밀번호를 사용할 수 있다. 크래킹하기 어렵도록 복잡한 비밀번호를 사용하는 것과 괜찮은 비밀번호 만료 정책 외에는 실질적으로 방법이 없다.
### 13.5.5 악의적인 프락시와 중간자 공격(Man-in-the-Middle Attack)
프락시 중 하나가 악의적이거나 보안이 허술하다면 클라이언트는 중간자 공격에 취약한 상태가 될 가능성이 있다. 가능한 해결책은 클라이언트가 사용자에게 인증의 강도를 시각적으로 보여주는 것, 클라이언트가 가능한 한 가장 강한 인증을 선택하도록 설정하는 것 등이 있다. 그러나 가능한 한 가장 강한 인증 제도를 사용한다 해도, 클라이언트는 여전히 도청에 취약하다. 이런 공격을 방어할 유일한 실패하지 않는 방법은 SSL을 사용하는 것이다.
### 13.5.6 선택 평문 공격
다이제스트 인증을 사용하는 클라이언트는 응답을 생성하기 위해 서버가 제공한 난스를 사용한다. 그러나 만약 보안이 허술하거나 악의적인 프락시가 트래픽 중간에 끼어든다면, 그것은 어렵지 않게 클라이언트가 응답 계산을 하기 위한 난스를 제공할 수 잇다. 응답을 계산하기 위해 알려진 키를 사용하는 것은 응답의 암호 해독을 쉽게 하며, 이것을 선택 평문 공격이라 부른다.
#### 미리 계산된 사전 공격
공격 서버는 미리 결정된 난스와 자주 쓰이는 비밀번호들로 응답의 집합을 생성하고 사전을 만든다. 일단 꽤 큰 사전이 만들어지면, 공격 서버/프락시는 트래픽을 차단하고 미리 결정된 난스를 클라이언트로 전송하기 시작한다. 클라이언트로 응답을 받을 때, 공격자는 대응되는 항목을 생성한 사전에서 찾는다. 만약 대응되는 것이 있으면, 공격자는 특정 사용자의 비밀번호를 손에 넣은 것이다.
#### 자동화된 무차별 대입 공격
미리 계산된 요약을 맞춰보려 시도하는 대신, 많은 컴퓨터를 동원해 주어진 범위에서 가능한 모든 비밀번호를 열거한다. 컴퓨터가 빨라질수록 무제한 공격의 성공 가능성은 점점 더 높아진다.

### 13.5.7 비밀번호 저장
다이제스트 인증 메커니즘은 사용자 응답을 서버 내부에 저장된 것과 비교하며, 인증 비밀번호 파일이 유출되면 영역의 모든 문서는 즉각 공격자에게 노출된다.
- 비밀번호 파일이 평문으로 된 비밀번호를 포함하고 있다고 생각하고 안전하게 보호한다.
- 영역 이름이 유일함을 보장하며, 비밀번호 파일이 유출되더라도 피해를 특정 영역으로 국소화한다. 호스트와 도메인을 포함한 완전한 영역 이름은 이 요구를 만족한다.

## 13.6 추가 정보
