# 14. 보안 HTTP
## 14.1 HTTP를 안전하게 만들기
- 서버 인증: 클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기하고 있음을 알 수 있어야 한다.
- 클라이언트 인증: 서버는 자신이 가짜가 아닌 진짜 사용자와 이야기하고 있음을 알 수 있어야 한다.
- 무결성: 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 한다.
- 암호화: 클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 한다.
- 효율: 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야 한다.
- 편재성(Ubiquity): 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
- 관리상 확장성: 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
- 적응성: 현재 알려진 최선의 보안 방법을 지원해야 한다.
- 사회적 생존성: 사회의 문화적, 정치적 요구를 만족시켜야 한다.
### 4.1.1 HTTPS
HTTPS를 사용할 때, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화

HTTPS는 HTTP의 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작하는데, 이 보안 계층은 안전 소켓 계층(Secure Sockets Layer, SSL) 혹은 그를 계승한 전송 계층 보안(Transport Layer Security, TLS)을 이용하여 구현

어려운 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어나기 때문에, 보안 HTTP를 사용하기 위해 웹 클라이언트와 서버가 프로토콜을 처리하는 로직을 크게 변경할 필요는 없음

대부분의 경우, TCP 입력/출력 호출을 SSL 호출로 대체하고, 보안 정보를 설정하고 관리하기 위한 몇 가지 호출을 추가하기만 하면 됨
## 4.2 디지털 암호학
- 암호: 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
- 키: 암호의 동작을 변경하는 숫자로 된 매개변수
- 대칭키 암호 체계: 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- 비대칭키 암호 체계: 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
- 디지털 서명: 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- 디지털 인증서: 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

### 14.2.1 비밀 코드의 기술과 과학
암호법(cryptography)은 메시지 인코딩과 디코딩에 대한 과학이자 기술(art)
### 14.2.2 암호(cipher)
암호법은 암호라 불리는 비밀 코드에 기반

암호란 메시지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법

인코딩되기 전의 원본 메시지는 텍스트 혹은 평문

암호가 적용되어 코딩데시지는 보통 암호문

### 14.2.3 암호 기계
초기에 사람이 직접 인코딩하고 디코딩해야 했기 때문에, 간단하며 암호화 작업을 연필과 정이, 암호첩(code book)으로 수행

기술이 진보하며 복잡한 암호로 메시지를 빠르게 인코딩하고 디코딩하는 기계를 만듦

### 14.2.4 키가 있는 암호
기계 내에는 암호의 동작방식을 변경할 수 있는 큰 숫자로 된 다른 값을 설정할 수 있는 다이얼이 달려있으며, 올바른 다이얼 설정(키 값)이 없이는 디코더가 동작하지 않음

암호 매개변수를 키라고 부르며, 암호 키는 하나의 암호 기계를 여러 가상 암호 기계의 집합처럼 만들주며, 이 가상 암호 기계들은 서로 다른 키 값을 갖고 있기 때문에 제각각 다르게 동작
### 14.2.5 디지털 암호
- 속도 및 기능에 대한 기계 장치의 한계에서 벗어남으로써, 복잡한 인코딩과 디코딩 알고리즘이 가능해졌다.
- 매우 큰 키를 지원하는 것이 가능해져서, 단일 암호 알고리즘으로 키의 값마다 다른 수조 개의 가상 암호 알고리즘을 만들어낼 수 있게 되었다. 키가 길수록 인코딩의 많은 조합이 가능해지고 무작위로 추측한 키에 의한 크래킹이 어려워진다.

## 14.3 대칭키 암호법
인코딩 할 때 사용하는 키가 디코딩을 할 때와 같음

발송자는 공유된 비밀 키를 메시지를 암호화하고 결과인 암호문을 수신자에게 발송하기 위해 사용

수신자는 암호문을 받은 뒤 같은 공유된 키를 사용하여 평문을 복원하기 위해 해독 함수를 적용
### 14.3.1 키 길이와 열거 공격(Enumeration Attack)
무차별로 모든 키 값을 대입해보는 열거 공격 => 128비트 키를 사용한 대칭키 암호는 매우 강력한 것으로 간주됨
### 14.3.2 공유키 발급하기
발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야 함

개인 비밀 키를 생성하고 기억해야 하므로 관리하기 어려움

## 14.4 공개키 암호법
한 쌍의 호스트가 하나의 인코딩/디코딩 키를 사용하는 대신, 공개키 암호 방식은 두 개의 비대칭 키를 사용

하나는 호스트의 메시지를 인코딩하기 위한 것이며, 다른 하나는 호스트의 메시지를 디코딩하기 위한 것이고 메시지를 디코딩하는 능력은 소유자에게만 부여함

공개키 암호화 기술은 보안 프로토콜을 전 세계의 모든 컴퓨터 사용자에게 적용하는 것을 가능하게 
### 14.4.1 RSA
다음의 내용을 알고 있어도 개인키를 계산할 수 없다는 것을 확신시켜주는 것이 공개키 비대칭 암호의 과제
- 공개키
- 가로채서 얻은 암호문의 일부(네트워크를 스누핑해서 획득)
- 메시지와 그것을 암호화한 암호문(인코더에 임의의 텍스트를 넣고 실행해서 획득)

RSA는 모든 요구를 만족하는 공개키 암호 체계 중 유명한 하나
### 14.4.2 혼성 암호 체계와 세션 키
공개키 암호 방식의 알고리즘은 계산이 느린 경향

## 14.5 디지털 서명
암호 체계는 메시지를 암호화하고 해독하는 것뿐 아니라, 누가 메시지를 썼는지 알려주고 그 메시지가 위조되지 않았음을 증명하기 위해 메시지에 서명을 하도록하는데 이용 가능
### 14.5.1 서명은 암호 체크섬이다
- 서명은 메시지를 작성한 저자가 누군지 알렺다. 저자는 저자의 극비 개인 키를 갖고 있기 때문에, 오직 저자만이 이 체크섬을 계산할 수 있다. 체크섬은 저자의 개인 '서명'처럼 동작한다.
- 서명은 메시지 위조를 방지한다. 만약 악의적인 공격자가 송신 중인 메시지를 수정했다면, 체크섬은 더 이상 그 메시지와 맞지 않게 될 것이다. 그리고 체크섬은 저자의 비밀 개인 키에 관련되어 있기 때문에, 침입자는 그 위조된 메시지에 대한 올바른 체크섬을 날조해낼 수 없을 것이다.
## 14.6 디지털 인증서
디지털 인증서(certs)는 신뢰할 수 있는 기관으로부터 보증받은 사용자나 회사에 대한 정보를 담고 있음
### 14.6.1 인증서의 내부
- 대상의 이름(사람, 서버, 조직 등)
- 유효 기간
- 인증서 발급자(누가 이 인증서를 보증하는가?)
- 인증서 발급자의 디지털 서명
### 14.6.2 X.509 v3 인증서
단일 표준은 없으나, 오늘날 대부분의 인증서는 그들의 정보를 X.509라 불리는 표준화된 서식에 저장하고 있음

X.509 v3 인증서는 인증 정보를 파싱 가능한 필드에 넣어 구조화하는 표준화된 방법을 제공

|필드|설명|
|:--:|:--:|
|버전|이 인증서가 따르는 X.509인증서 버전의 번호. 요즘은 보통 버전 3|
|일련번호|인증기관에 의해 생성된 고유한 정수. CA로부터의 각 인증서는 반드시 고유한 일련번호를 가져야 한다|
|서명 알고리즘 ID|서명을 위해 사용된 암호 알고리즘. 예를 들면, "RSA 암호화를 이용한 MD2 요약"|
|인증서 발급자|인증서를 발급하고 서명한 기관의 이름. X.500 포맷으로 기록되어 있다|
|유효 기간|인증서가 유효한 기간. 시작일과 종료일로 정의된다|
|대상의 이름|인증서에 기술된, 사람이나 조직과 같은 엔터티. 이 대상 이름은 X.500 포맷으로 기록되어 있다|
|대상의 공개 키 정보|인증 대상의 공개 키, 공개 키에 사용된 알고리즘, 추가 매개변수|
|발급자의 고유 ID(선택적)|발급자의 이름이 겹치는 경우를 대비한, 인증서 발급자에 대한 선택적인 고유한 식별자|
|대상의 고유 ID(선택적)|대상의 이름이 겹치는 경우를 대비한, 인증 대상에 대한 선택적인 고유한 식별자|
|확장|선택적인 확장 필드의 집합. 각 확장 필드는 중요한 것인지 그렇지 않은지가 표시되어 있음. 중요한 확장은 중요하기 때문에 인증서 사용자에 의해 반드시 이해되어야 한다. 만약 인증서 사용자가 중요한 확장 필드를 이해하지 못한다면, 인증서를 거절해야한다|
|인증기관 서명|위의 모든 필드에 대한 인증기관의 디지털 서명. 명시된 서명 알고리즘을 사용한다|
### 14.6.3 서버 인증을 위해 인증서 사용하기
사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져옴
## 14.7 HTTPS의 세부사항
HTTPS는 HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호화 기법의 강력한 집합을 결합한 것

이 기법들의 집합은 무정부 상태의 분권화된 글로벌 인터넷 환경에서도 HTTPS를 매우 안전한 동시에 매우 유연하고 관리하기 쉽게 만들어줌
### 14.7.1 HTTPS의 개요
HTTPS는 HTTP 메시지를 TCP로 보내기 전에 먼저 그것들을 암호화하는 보안 계층으로 보냄
### 14.7.2 HTTP 스킴
### 14.7.3 보안 전송 셋업
1. HTTPS에서, 클라이언트는 먼저 웹 서버의 443 포트(보안 HTTP의 기본 폰트)로 연결한다.
2. 연결이 되고 나면, 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화한다.
3. 핸드셰이크가 완료되면 SSL 초기화는 완료되며, 클라이언트는 요청 메시지를 보안 계층에 보낼 수 있다.
4. 이 메시지는 TCP로 보내지기 전에 암호화된다.
### 14.7.4 SSL 핸드셰이크
- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원을 인증
- 채널을 암호화하기 위한 임시 세션 키 생성
### 14.7.5 서버 인증서
SSL 은 서버 인증서를 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 날라주는 상호 인증을 지원
### 14.7.6 사이트 인증서 검사
SSL 자체는 사용자에게 웹 서버 인증서를 검증할 것을 요구하지 않지만, 최신 웹브라우저들 대부분은 인증서에 대해 간단하게 기본적인 검사를 하고 결과를 철한 검사를 할 수 있는 방법과 함께 사용자에게 알려
#### 날짜 검사
브라우저는 인증서가 유효함을 확인하기 위해 인증서의 시작 및 종료일을 검사
#### 서명자 신뢰도 검사
모든 인증서는 서버를 보증하는 인증 기관에 의해 서명되어 있음
#### 서명 검사
서명 기관이 믿을 만하다고 판단하면, 브라우저는 서명기관의 공개키를 서명에 적용하여 체크섬과 비교해봄으로써 인증서의 무결성을 검사
#### 사이트 신원 검사
누군가 다른 이의 인증서를 복사하거나 트래픽을 가로채는 것을 방지하기 위해, 대부분의 브라우저는 인증서의 도메인 이름이 대화중인 서버의 도메인 이름과 비교하여 맞는지 검사
### 14.7.7 가상 호스팅과 인증서
## 14.8 진짜 HTTPS 클라이언트
SSL은 복잡한 바이너리 프로토콜이기 때문에, 가공되지 않은 SSL 트래픽을 직접 보내는 것은 비권장
### 14.8.1 OpenSSL
### 14.8.2 간단한 HTTPS 클라이언트
### 14.8.3 우리의 단순한 OpenSSL 클라이언트 실행하기
## 14.9 프락시를 통한 보안 트래픽 터널링
클라이언트는 종종 그들을 대신하여 웹 서버에 접근해주는 웹 프락시 서버를 이용

클라이언트가 서버로 보낼 데이터를 서버의 공개키로 암호화하기 시작했다면 프락시는 더 이상 HTTP 헤더를 읽을 수 없음

HTTPS 터널링 프로토콜을 사용해서 르라이언트는 먼저 프락시에게 자신이 연결하고자 하는 안전한 호스트와 포트를 말해주면, 클라이언트는 내용을 프락시가 읽을 수 있도록 암호화가 시작되기 전의 평문으로 말해
## 14.10 추가 정보
### 14.10.1 HTTP 보안
### 14.10.2 SSL과 TLS
### 14.10.3 공개키 인프라
### 14.10.4 디지털 암호
