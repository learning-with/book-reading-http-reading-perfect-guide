# 14 보안 HTTP

디지털 암호화를 이용한 도청이나 위조로부터 HTTP 트랜잭션을 안전하게 보호하는 복잡하고 적극적인 기술을 알아보자.

## 14.1 HTTP를 안전하게 만들기

보다 중요한 트랜잭션을 위해 HTTP와 디지털 암호화 기술의 결합이 필요.

> 필요한 HTTP 보안 기술

- 서버 인증
- 클라이언트 인증
- 무결성
- 암호화
- 효율
- 편재성(Ubiquity)
- 관리상 확장성
- 적응성
- 사회적 생존성

### 14.1.1 HTTPS

모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화됨.

- 안전 소켓 계층(Secure Sockets Layer,SSL)혹은 전송 계층 보안(Transport Layer Security,TLS)을 이용하여 구현됨.

## 14.2 디지털 암호학

- **암호** 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
- **키** 암호의 동작을 변경하는 숫자로 된 매개변수
- **대칭키 암호 체계** 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- **비대칭키 암호 체계** 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
- **디지털 서명** 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- **디지털 인증서** 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

### 14.2.1 비밀 코드의 기술과 과학

암호법(crytography) : 메시지 인코딩과 디코딩에 대한 과학이자 기술(art), 암호법은 수표에 손으로 쓴 서명이나 봉투의 양각된 왁스 봉인과 같인 누군가 어떤 메시지나 트랜잭션 저자임을 증명하는 데도 사용될 수 있음.

### 14.2.2 암호(cipher)

암호란? 메시지를 인코딩하는 어떤 특정한 방법과 그 비밀 메시지를 디코딩하는 방법.

> 예시 : 도깨비어 ex) 안녕하세요 -> 안산녕셩하사세세요쇼

### 14.2.3 암호 기계

과거에는 암호첩(code book)으로 사람이 직접 인코딩, 디코딩하였지만 기술이 발전함으로 기계가 등장함.

### 14.2.4 키가 있는 암호

암호 매개변수 키를 활용해 올바른 다이얼 설정(키 값)이 없으면 디코더가 동작하지 않게 설정함. 흔히 쓰이는 가장 장력한 암호들 중 다수가 누구나 보고 연수할 수 있도록 소스 코드를 공개하고 있음.

### 14.2.5 디지털 암호

- 속도 및 기능에 대한 기계 장치의 한계에서 벗어남으로써, 복잡한 인코딩과 디코딩 알고리즘이 가능해짐.
- 매우 큰 키를 지원하는 것이 가능해져서 단일 암호 알고리즘으로 키의 값마다 다른 수조 개의 가상 암호 알고리즘을 만들어 낼 수 있게 됨. 키가 길수록 인코딩의 많은 조합이 가능해지고 무작위로 추측한 키에 의한 크래킹이 어려워짐.

## 14.3 대칭키 암호법

인코딩 할 대 사용하는 키가 디코딩 할 대와 같을 경우 대칭키 암호라 불림.
잘 알려진 대칭키 암호 알고리즘으로는 DES, Triple-DES, RC2, RC4등이 있음.

### 14.3.1 키 길이와 열거 공격(Enumeration Attack)

모든 키값을 무차별로 대입해보는 공격 = 열거 공격, 길면 길수록 대입하는 시간이 길어져 알아내기 어려움.

### 14.3.2 공유키 발급하기

대칭키 암호의 단점 중 하나는 발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야 한다는 점. 관리자의 경우 이를 위해 수천 개의 키를 생성하고 기억해야됨.

## 14.4 공개키 암호법

공개키 암호 방식은 두 개의 비대칭 키를 사용함. 공개키 암호화 기술은 보안 프로토콜을 전 세계의 모든 컴퓨터 사용자에게 적용하는 것을 가능하게 함.
표준화된 공개키 기술 묶음을 만드는 것의 중요성 때문에 거대한 공개 키 인프라(Public-Key Infrastrucure, PKI) 표준화 작업이 25년 넘게 진행 중임.

### 14.4.1 RSA

- 공개키
- 가로채서 얻은 암호문의 일부
- 메시지와 그것을 암호화한 암호문

### 14.4.2 혼성 암호 체계와 세션 키

비대칭 공개키 암호 방식은 누구나 공개키만 알면 그 키에 대응되는 공개 서버에 안전하게 메시지를 보낼 수 있게 해주므로 훌륭함. 단 계산이 느린 경향이 있음. 실제로는 대칭과 비대칭 방식을 섞은 것이 쓰임.노드들 사이의 안전한 의사소통 채널을 수립할 때는 공개 키를 암호 사용, 안전한 채널을 통해 임시의 무작위 대칭 키를 생성하고 교환하여 이후의 나머지 데이터를 암호화할 때, 빠른 대칭 키를 사용하는 방식이 쓰임.

## 14.5 디지털 서명

암호 체계는 메시지를 암호화하고 해독하는 뿐만아니라 누가 메시지를 썼는지 알려주고 메시지가 위조되지 않았음을 증명하기 위해 메시지에 서명을 하도록 하는데에 이용될 수 있음.

### 14.5.1 서명은 암호 체크섬이다

- 서명은 메시지를 작성한 저자가 누군지 알려줌. 오직 저자만이 이 체크섬을 계산할 수 있고, 체크섬은 저자의 개인 서명처럼 동작함.
- 서명은 메시지 위조를 방지함. 체크섬은 저자의 비밀 개인 키에 관련되어 있기 때문에, 침입자는 위조된 메시지에 대해 올바른 체크섬을 날조해낼 수 없음.

## 14.6 디지털 인증서

= 인터넷 신분증, certs라고 붙어있는 신회할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있음.

### 14.6.1 인증서의 내부

인증 기관에 의해 디지털 서명된 정보의 집합이 담김. 대상과 사용된 서명 알고리즘에 대한 서술적인 정보뿐 아니라 대상의 공개키도 포함함.

- 대상의 이름(사람, 서버, 조직 등)
- 유효 기간
- 인증서 발급자(누가 이 인증서를 보증하는 가)
- 인증서 발급자의 디지털 서명

### 14.6.2 X.509 v3 인증서

X.509 v3 인증서는 인증 정보를 파싱 가능한 필드에 넣어 구조화하는 표준화된 방법을 제공함. X.509 기반 인증서에는 웹 서버 인증서, 클라이언트 이메일 인증서, 소프트웨어 코드사인 인증서, 인증기관 인증서를 비롯한 몇가지 변종이 있음

### 14.6.3 서버 인증을 위해 인증서 사용하기

서버가 인증서를 갖고 있지 않다면 보안 커넥션은 실패함. 브라우저가 인증서를 받으면 서명 기관을 검사함. 그 기관이 공공이 신회할만한 서명 기관이라면 브라우저는 이미 공개키를 알고 있어 브라우저는 그 서명을 검증할 수 있음. 만약 서명 기관이 모르는 곳이라면 브라우저는 그 서명 기관을 신뢰할지 확신할 수 없으므로 대개 사용자에게 서명 기관을 신뢰하는지 확인하기 위한 대화상자를 보여줌.

> 서버 인증서가 갖고있는 필드

- 웹 사이트의 이름과 호스트명
- 웹 사이트의 공개키
- 서명 기관의 이름
- 서명 기관의 서명

## 14.7 HTTPS의 세부사항

HTTP의 가장 유명한 보안 버전 주류 상용 브라우저와 서버에 구현돼있음. 분산된 웹 애플리케이션의 광역 보안 관리에 있어 매우 중요함.

### 14.7.1 HTTPS 개요

보안 전송 계층을 통해 전송되는 HTTP임. 암호화되지 않은 HTTP 메시지를 TCP를 통해 전 세계의 인터넷 곳곳으로 보내는 대신 HTTPS는 HTTP 메시지를 TCP로 보내기 전에 암호화하는 보안 계층(SSL또는 TLS)으로 먼저 보냄.

### 14.7.2 HTTPS 스킴

HTTP은 선택적임. HTTPS가 적용돼 있는 경우 스킴이 `https://`로 시작함. 만약 URLdl https 스킴을 갖고 있다면 클라이언트는 서버에 443(기본값)포트로 연결하고 서버와 바이너리 포맷으로 된 몇몇 SSL 보안 매개변수를 교환하면서 핸드 셰이크를 하고 암호화된 HTTP 명령이 뒤를 이음.

### 14.7.3 보안 전송 셋업

- 암호화되지 않은 HTTP에서 클라이언트는 웹 서버읭 80번 포트로 TCP 커넥션을 열고 요청 메시지를 보내고, 응답 메시지를 받고, 커넥션을 닫음.
- HTTPS에서는 443연결 -> TCP연결이 된 후 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL계층을 초기화함.
  핸드셰이크가 완료되면 SSL 초기화는 완료되며 클라이언트는 요청 메시지를 보안 계층에 보낼 수 있음. 이 메시지는 TCP로 보내지기 전에 암호화됨.

### 14.7.4 SSL 핸드 셰이크

- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원을 인증
- 채널을 암호화하기 위한 임시 세션 키 생성

### 14.7.5 서버 인증서

보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구함. 서버 인증서는 조직의 이름, 주소, DNS 도메인 이름, 그 외의 정보를 보여주는 X.509 v3에서 파생된 인증서임.
사용자 클라이언트 소프트웨어는 모든 것을 믿을 만한 것인지 확인하기 위해 인증서를 검증할 수 있음.

### 14.7.6 사이트 인증서 검사

SSL자체는 ㅏ용자에게 웹 서버 인증서를 검증할 것을 요구하지는 않지만 최신 웹 브라우저들 대부분은 인증서에 대해 간단한 기본적인 검사를 함.

- 날짜 검사, 서명자 신뢰도 검사, 서명 검사, 사이트 신원 검사

### 14.7.7 가상 호스팅과 인증서

가상 호스트(하나의 서버에 여러 호스트 명)로 운영되는 사이트의 보안 트래픽 다루기는 까다로움. 보안 트랜잭션을 시작하는 모든 사용자를 호스팅 제공자의 공식 DNS로 리다이렉트하는데 가상 호스팅 되는 사이트의 인증서 관리는 다소 까다로울 수 있음.

## 14.8 진짜 HTTPS 클라이언트

SSL은 복잡한 바이너리 프로토콜임. SSL 클라이언트와 서버 프로그래밍을 쉽게 만들어주는 상용 혹은 오픈 소스 라이브러리들이 존재함.

### 14.8.1 OpenSSL

### 14.8.2 간단한 HTTPS 클라이언트

### 14.8.3 우리의 단순한 OpenSSL 클라이언트 실행하기

## 14.9 프락시를 통한 보안 트래픽 터널링

클라이언트는 종종 그들을 대신하여 웹 서버에 접근해주는 웹 프락시 서버를 이용함.
프락시는 방화벽 라우터가 HTTP 트래픽이 교환을 허락한 유일한 장치이며 바이러스 검사나 기타 콘텐츠 제어를 수행할 것임. 만약 프락시가 HTTP헤더를 읽을 수 없담녀 프락시는 요청을 어디로 보내야 하는지 알 수 없게 됨. HTTPS가 프락시와도 잘 동작할 수 있게 하기 위해, 클라이언트가 프락시에게 어디에 접속하려고 하는지 말해주는 방법을 수정해야함. 이 방법으로 인기있는게 HTTPS 터널링 프로토콜 사용해서 클라이언트는 자신이 연결하고자하는 안전한 호스트와 포트를 프락시에게 말해줌.

## 14.10 추가 정보

### 14.10.1 HTTP보안

### 14.10.2 SSL과 TLS

### 14.10.3 공개키 인프라

### 14.10.4 디지털 암호
