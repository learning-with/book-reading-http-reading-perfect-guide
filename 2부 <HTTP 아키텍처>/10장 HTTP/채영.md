# 10. HTTP/2.0

HTTP/2.0 8번째 초안 기준으로 작성됨.

## 10.1 HTTP/2.0의 등장 배경

> HTTP/1.1

- 구현의 단순성과 접근성에 주안점을 두고 최적화 됨.
- 요청하나에 응답하나, 응답이와야만 다음 요청ㅇ을 보낼 수 있음
- 심각한 회전 지연(latency) 발생
- latency를 피하기위해 병렬 커넥션이나 파이프라인 커넥션이 도입되었지만, 성능 개선에 대한 근본적인 해결책은 되지 못함.

> SPDY 기반의 HTTP/2.0 프로토콜 설계.

- 더 빠른 웹을 위한 실험적인 프로토콜 (SPDY)의 초안을 그대로 가져와 HTTP/2.0 초안을 만들기 시작함.

## 10.2 개요

HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에 동작. 이때 TCP 커넥션을 초기화하는 것은 클라이언트임.

> HTTP/2.0

- HTTP 헤더는 압축되어 담김.
- 요청과 응답은 한 개의 스트림이 처리함.
- 하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어질 수 있음. = 여러 개의 요청/응답 동시에 처리 가능
- 우선순위 부여 기능 제공
- 서버 푸시 기능 도입
- 기존의 HTTP/1.1과 호환성 유지

> 메시지 의미

- Content-Length 헤더 : 본문 길이 `:content-length`
- 상태줄을 통해 표현하던 404 Not Found는 `:status`헤더로 404 표현

## 10.3 HTTP/1.1과 차이점

### 10.3.1 프레임

HTTP/2.0의 모든 메시지는 프레임에 담겨 전송됨.

- 총 10가지의 프레임을 정의함. 페이로드의 형식이나 내용은 프레임의 종류에 따라 다름.

  > `DATA`, `HEADERS`, `PRIORITY`,`RST_STREAM`, `SETTINGS`,`PUSH_PROMISE`, `PING`, `GOAWAY`, `WINDOW_UPDATE`, `CONTINUATION`

### 10.3.2 스트림과 멀티플렉싱

> ### 스트림
>
> HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스.

- 한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어짐.
- 클라이언트는 새 스트림을 만들어 스트림을 통해 HTTP 요청을 보냄. 요청을 받은 서버는 받은 요청과 같은 스트림으로 응답을 보냄. 요청, 응답을 주고 받으면 스트림이 닫힘.
- 하나의 HTTP/2.0 커넥션을 통해 여러 개의 요청을 동시에 보낼 수 있음
- 우선 순위를 가질 수 있음. 예시로 네트워크 대역폭이 충분하지 않아 프레임의 전송이 느리다면, 웹 브라우저는 보다 중요한 리소스를 요청하는 스트림에게 더 높은 우선 순위를 부여할 수 있음.

- 동시에 여러 개의 스트림을 사용하면 커넥션을 오래 사용할 경우 스트림이 블록될 수 있는 우려가 있지만 그런 경우엔 커넥션을 다시 맺으면 됨. HTTP/2.0에 WINDOW_UPDATE 프레임을 이용한 흐름 제어(flow-control)를 통해, 스트림들이 서로 간섭해서 망가지는 것을 막아줌.

### 10.3.3 헤더 압축

HTTP/2.0에서는 HTTP 메시지의 헤더를 압축하여 전송. 헤더는 HPACK 명세에 정의된 헤더 압축 방법으로 정의된 뒤 헤더 블록조각들로 쪼개져 전송됨. 받는 쪽에서 압축을 풀어 원래의 헤더 집합으로 복원함.

- HPACK은 헤더를 압축하고 해제할 대 "압축 콘텍스트"를 사용함.
- 오동작하지 않으려면 항상 올바른 압축 콘텐스트를 유지해야 함.
- 문제가 있을 경우 COMPRESSION_ERROR와 함께 커넥션을 끊어내야함.

### 10.3.4 서버 푸시

서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에 유용함.

- 리소스를 푸시하려는 서버는 먼저 클라이언트에게 자원을 푸시할 것임을 `PUSH_PROMISE` 프레임을 보내어 미리 알려주어야함.
- 클라이언트가 `PUSH_PROMISE` 프레임을 받으면 예약됨(원격)상태가 됨.
- 예약됨 상태에서 `RST_STREAM`을 보내면 그 스트림은 즉각 닫히게 됨.
- 스트림이 닫히기 전까지는 클라리언트는 서버가 푸시하려고 하는 리소스를 요청해선 안됨.(서버가 푸시하려고 하는 자원을 클라이언트가 중복 요청을 하게되는 상황을 피하기 위함)

> 서버 푸시 시 주의 사항 기억하기 p293

## 10.4 알려진 보안 이슈

### 10.4.1 중개자 캡슐화(Intermediary Encapsulation Attacks)

- HTTP/2.0 메시지가 HTTP/1.1 메시지로 변경될 때 불법적이거나 위조된 HTTP/1.1 메시지로 번역될 수도 있음.
- HTTP/1.1 메시지를 HTTP/2.0 메시지로 번역할 때는 이런 문제 발생하지 X

### 10.4.2 긴 커넥션 유지로 인한 개인정보 누출 우려

## 10.5 추가 정보
