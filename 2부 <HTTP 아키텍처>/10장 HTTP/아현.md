# 10. HTTP/2.0
## 10.1 HTTP/2.0의 등장 배경
HTTP/1.1의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화되었음

커넥션 하나를 통해 요청 하나를 보내고 그에 대한 응답을 하나만 받는 HTTP의 메시지 교환 방식은 단순했으나, 응답을 받아야만 그다음 요청을 보낼 수 있기 때문에 심각한 회전 지연(latency)을 피할 수 없었음

이 문제를 회피하기 위해 병렬 커넥션이나 파이프라인 커넥션이 도입되었지만 성능 개선에 대한 근본적인 해결책은 되지 못함

## 10.2 개요
HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작하며, TCP 커넥션을 초기화하는 것은 클라이언트

HTTP/2.0 요청과 응답은 길이가 정의된 한 개 이상의 프레임에 담김

프레임들에 담긴 요청과 응답은 스트림을 통해 보내지며, 한 개의 스트림이 한 쌍의 요청과 응답을 처리하여 하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어질 수 있어 요러 개의 요청과 응답을 동시에 처리하는 것이 가능해짐

스트림에 대한 흐름 제어와 우선순위 부여 기능도 제공

기존 웹 애플리케이션들과 호환성을 최대한 유지하기 위해 요청과 응답 메시지의 의미를 HTTP/1.1과 같도록 유지

## 10.3 HTTP/1.1과의 차이점
### 10.3.1 프레임
모든 메시지는 프레임에 담겨 전송됨
### 10.3.2 스트림과 멀티플렉싱
스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스

스트림은 우선순위를 가질 수 있음

서버와 클라이언트는 스트림을 만들 때 협상을 위해 TCP를 주고받느라 시간을 낭비할 필요 없이 협상 없이 일방적으로 만듦

### 10.3.3 헤더 압축
헤더의 크기가 회전 지연과 대역폭 양쪽에 실질적인 영향을 끼치게 되자 HTTP/2.0에서는 HTTP 메시지의 헤더를 압축하여 전송

헤더는 HPACK 명세에 정의된 헤더 압축 방법으로 압축된 뒤 '헤더 블록 조각'들로 쪼개져서 전송됨

받는 쪽에서는 이 조각들을 이은 뒤 압축을 풀어 원래의 헤더 집합으로 복원

### 10.3.4 서버 푸시
서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있음

서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용

## 10.4 알려진 보안 이슈
### 10.4.1 중개자 캡슐화 공격(Intermediary Encapsulation Attacks)
HTTP/2.0 메시지를 중간의 프락시가 HTTP/1.1 메시지로 변환할 때 메시지의 의미가 변질될 가능성이 있음

### 10.4.2 긴 커넥션 유지로 인한 개인정보 노출 우려
### 10.5 추가 정보
