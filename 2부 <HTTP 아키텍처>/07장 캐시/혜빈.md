# 07 캐시

## 7.1 불필요한 데이터 전송

자주 쓰이는 웹 페이지에는 서로 다른 여러 클라이언트가 접근한다.

첫 번째 요청에 대한 응답을 캐시에 보관하여 중복 트래픽을 줄인다.

## 7.2 대역폭 병목

로컬 네트워크 클라이언트의 대역폭 > 원격 서버의 대역폭

클라이언트들이 서버에 접근하는 속도는 그 경로에 있는 가장 느린 네트워크의 속도와 같다.

LAN에 있는 캐시로부터 사본을 가져오면 성능을 대폭 개선할 수 있다.

## 7.3 갑작스런 요청 쇄도(Flash Crowds)

갑작스런 사건으로 인해 많은 클라이언트가 동시에 같은 웹 문서에 접근할 수 있다.

트래픽이 갑자기 늘어나면 네트워크와 웹 서버에 심각한 장애가 일어날 수 있다.

## 7.4 거리로 인한 지연

대역폭이 충분하더라도 거리 자체가 문제가 될 수 있다.

1. 빛의 속도 그 자체가 트래픽을 지연시킨다. 한 지점에서 다른 지점까지 신호가 전달되는 데는 최소한 빛의 속도만큼의 지연이 발생한다. (실제로는 신호는 빛보다 약간 느리게 이동한다. 또한 네트워크가 모두 일직선으로 놓여있지 않기 때문에 지연이 더 발생한다.)

2. 모든 네트워크 라우터는 트래픽을 지연시킨다. 신호가 한 지점에서 다른 지점까지 가는 동안은 수많은 라우터, 게이트웨이, 스위치, 기지국 등을 거치게 된다.

## 7.5 적중과 부적중

캐시 적중(cache hit): 캐시에 요청이 도착했을 때, 요청에 대응하는 사본으로 요청을 처리하는 것

캐시 부적중(cache miss): 요청에 대응하는 사본이 없어서 원 서버로 전달되는 것

### 7.5.1 재검사(Revalidation)

HTTP 재검사: 캐시가 갖고 있는 사본이 최신인지 검사하는 것

전체 객체를 가져오지 않고도 콘텐츠가 최신인지 검사할 수 있다.

네트워크 대역폭이 부족하기 때문에 모든 문서를 재검사하지는 않는다.

1. 클라이언트가 사본을 요청하였으며 2) 사본이 충분히 오래된 경우에만 재검사를 한다.

### 7.5.2 적중률

캐시 적중률 (문서 적중률)

- 캐시가 요청을 처리하는 비율

- 얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지 보여줌

- 트랜잭션에 따르는 고정 소요 시간이 있기 때문에, 문서 적중률을 개선하면 전체 대기시간을 줄일 수 있다.

### 7.5.3 바이트 적중률

- 크기가 큰 문서는 덜 접근되더라도 전체 트래픽에는 더 큰 영향을 줄 수 있다.

- 바이트 적중률: 캐시를 통해 제공된 바이트의 비율

- 트래픽이 절감된 정도를 표현한다. ex) 100%: 모든 바이트가 캐시에서 왔기 때문에, 어떤 트래픽도 인터넷으로 나가지 않음

- 대역폭 절약을 최적화한다.

### 7.5.4 적중과 부적중의 구별

- 응답이 캐시 적중이었든 원 서버 접근이든 모두 200 OK 응답이 내려온다.

- Date 헤더 값을 현재 시각과 비교해서 응답의 생성일이 더 오래되었다면 응답이 캐시된 것이다.

- Age 헤더는 문서가 캐시에 머무른 시간을 초단위로 표시한다.

- 어떤 상용 프락시 캐시는 Via 헤더에 추가 정보를 붙이기도 한다.

## 7.6 캐시 토폴로지

### 7.6.1 개인 전용 캐시

ex. 웹브라우저에 내장된 캐시

### 7.6.2 공용 프락시 캐시

ex. 프락시 캐시 (캐시 프락시 서버)

여러 요청에 대해 공유된 사본을 제공하여 트래픽을 줄인다.

수동 프락시를 지정하거나, 프락시 자동설정 파일을 설정하거나, 인터셉트 프락시를 사용할 수 있다.

### 7.6.3 프락시 캐시 계층들

캐시 계층: 작은 캐시 부적중 -> 부모 캐시가 트래픽 처리하는 구조

클라이언트 주위에 작고 저렴한 캐시를 사용하고, 계층 상단에는 크고 강력한 캐시를 사용

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

캐시망
캐시에 대한 결정을 동적으로 내림

1. 부모 캐시와 원 서버 중 하나를 동적으로 선택한다.

2. 특정 부모 캐시를 동적으로 선택한다.

3. 부모 캐시에게 가기 전에 캐시된 사본을 로컬에서 찾아본다.

4. 다른 캐시들의 접근을 허용하되, 인터넷 트랜짓은 허용하지 않는다.

cf. 형제 캐시: 캐시끼리 연결되어 서로 찾아볼 수 있는 캐시. HTTP에서는 지원하지 않음.

## 7.7 캐시 처리 단계

### 7.7.1 단계 1: 요청 받기

네트워크로부터 도착한 요청 메시지를 읽는다.

### 7.7.2 단계 2: 파싱

메시지를 파싱하여 URL과 헤더들을 추출한다.

대소문자, 날짜 형식 차이, 절대 URL, 상대 URL 등의 차이를 숨긴다.

### 7.7.3 단계 3: 검색

로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아온다(그리고 로컬에 저장한다).

로컬 복사본은 메모리, 디스크, 근처의 다른 컴퓨터 등에 있을 수 있다.

### 7.7.4 단계 4: 신선도 검사

캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어본다.

### 7.7.5 단계 5: 응답 생성

새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.

응답을 원 서버에서 온 것처럼 보이게 하고 싶기 때문에, 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성한다.

클라이언트에 맞게 헤더를 조정한다.

클라이언트가 HTTP/1.1 응답을 기대하는 상황에서 서버가 HTTP/1.0 또는 HTTP/0.9 응답을 반환한 경우

캐시 신선도 정보 (Cache-Control, Age, Expires, Via) 삽입

단, Date 헤더를 조정해서는 안 된다. Date는 원 서버에서 최초로 생겨난 일시를 표현한다.

### 7.7.6 단계 6: 전송

네트워크를 통해 응답을 클라이언트에게 돌려준다.

### 7.7.7 단계 7: 로깅

(선택적으로) 로그파일에 트랜잭션에 대해 서술한 로그를 남긴다.

캐시에 대한 통계를 갱신한다.

### 7.7.8 캐시 처리 플로 차트

## 7.8 사본을 신선하게 유지하기

### 7.8.1 문서 만료

문서가 만료되기 전에는 서버와 접촉 없이 사본을 제공할 수 있지만, 문서가 만료되면 변경된 것이 있는지 검사하고 새로운 사본을 얻어 와야 한다.

### 7.8.2 유효기간과 나이

Cache-Control: max-age 헤더: 문서의 최대 나이 (초 단위)

Expires 헤더: 문서의 유효기간 (날짜)

### 7.8.3 서버 재검사

재검사 결과
콘텐츠가 변경됨: 새로운 사본을 가져오고 저장한 뒤 클라이언트에 보내준다

콘텐츠가 변경되지 않음: 새로운 헤더만 가져와서 캐시 안의 헤더들을 갱신한다 (ex. 새로운 만료일)

원 서버가 다운됨: 에러 메시지

결과가 부정확함: 경고 메시지를 부착된 사본을 보냄

매 요청마다 신선도를 검증할 필요가 없기 때문에, 서버 트래픽을 절약하고 사용자 응답 시간을 개선한다.

### 7.8.4 조건부 메서드와의 재검사

조건부 GET: GET 요청 메시지에 If-로 시작하는 헤더를 추가

### 7.8.5 If-Modified-Since: 날짜 재검사

If-Modified-Since: <date>, 줄여서 IMS 요청

리소스가 특정 날짜(캐시된 마지막 수정일) 이후로 변경된 경우에만 요청한 본문을 보내야 함

몇몇 웹 서버는 날짜 비교 대신 문자열 비교를 하기 때문에, "정확히 이 날짜에 마지막 변경이 일어난 것이 아니라면"이라는 의미로 사용되기도 함

리소스가 주어진 날짜 이후로 변경됨: 요청 성공, 새 문서가 새로운 만료 날짜와 함께 캐시에 반환

리소스가 주어진 날짜 이후로 변경되지 않음: 서버는 304 Not Modified 응답 메시지를 클라이언트에 돌려줌. 본문은 보내지 않지만 새로운 만료 날짜는 보내줌.

Last-Modified 서버 응답 헤더: 최근 변경 일시

### 7.8.6 If-None-Match: 엔터티 태그 재검사

날짜 검사의 문제점
내용에는 변화가 없어도 변경 시각은 바뀔 수 있음

철자나 주석 변경처럼 모든 캐시들이 다시 읽어들이기에는 사소한 변경일 수도 있음

어떤 서버들은 최근 변경 일시를 정확하게 판별하지 못함

1초보다 작은 간격으로 문서를 갱신하는 경우 1초가 충분하지 못한 정밀도가 될 수 있음

### 7.8.7 약한 검사기와 강한 검사기

### 7.8.8 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

서버가 엔터티 태그를 반환했다면 클라이언트는 엔터티 태그를 써야 함

서버가 Last-Modified 값만 반환했다면 클라이언트는 if-Modified-Since 검사를 할 수 있음

서버가 둘 다 반환했다면 클라이언트는 둘 다 사용해야 함 (HTTP/1.0과 HTTP/1.1 캐시 모두 지원하기 위함)

HTTP/1.1 원 서버는 엔터티 태그를 보내야 하고, Last-Modified 값을 같이 보낼 수도 있음

HTTP/1.1 캐시나 서버가 If-Modified-Since와 엔터티 태그 조건부 헤더를 모두 받았다면, 두 가지 조건에 모두 부합할 때만 304 Not Modified 응답을 보낼 수 있음

## 7.9 캐시 제어

### 7.9.1 no-cache와 no-store 응답 헤더

Cache-Control: no-store
캐시가 응답의 사본을 만드는 것을 금지함

캐시는 클라이언트에 no-store 응답을 전달하고 객체를 삭제함

Cache-Control: no-cache
실제로는 캐시 저장소에 저장될 수 있음

서버와 재검사하기 전에는 캐시에서 클라이언트로 제공될 수 없음

cf. Pragma: no-cache: HTTP/1.0+와의 하위호환성

### 7.9.2 Max-Age 응답 헤더

Cache-Control: max-age
문서가 서버로부터 온 이후 최대 유효 시간 (초 단위)

s-maxage 헤더는 공용 캐시에만 적용됨

### 7.9.3 Expires 응답 헤더

실제 만료 날짜 명시

많은 서버가 부정확한 시계를 갖고 있기 때문에 절대시각 대신 경과된 시간으로 표현하는 것이 나음

문서가 항상 만료되도록 Expires: 0과 같은 헤더를 보내는 것은 문법 위반임

### 7.9.4 Must-Revalidate 응답 헤더

때때로 캐시는 성능을 위해 만료된 객체를 제공할 수 있음

서버가 Cache-Control: must-revalidate 헤더를 보내면 캐시는 원 서버와의 재검사 없이 객체를 제공할 수 없음

원 서버가 고장난 상태면 504 Gateway Timeout error

### 7.9.5 휴리스틱 만료

응답에 Cache-control: max-age 헤더나 Expires 헤더 중 어느 것도 포함하지 않고 있는 경우

경험적인 방법으로 최대 나이를 계산해서 Heuristic Expiration 경고 헤더를 응답에 추가함

일반적으로는 1주일~하루 정도의 상한을 설정해 둠

아무런 단서가 없을 때는 한 시간이나 하루 같은 기본 유지 기간을 설정하거나, 보수적으로 수명을 0으로 설정

### 7.9.6 클라이언트 신선도 제약

라이언트는 Cache-control 헤더를 사용해 캐시 만료 제약을 엄격하게 또는 느슨하게 할 수 있다.

엄격하게
강제로 재검사하거나, 서버로부터 새로 가져온다. (ex. 수동 리프레시 버튼)

Cache-Control: min-fresh = 만료 시간 이전 최소 s초의 여유 시간이 남아 있어야 한다.

Cache-Control: max-age = s초보다 오래된 캐시된 문서를 반환할 수 없다.

느슨하게
성능, 신뢰성, 비용 개선을 위해 느슨하게 검사한다.

Cache-Control: max-stale = : 신선하지 않은 문서를 제공할 수 있다. 값이 있으면 s초 지난 것도 받아들인다.

Cache-Control: only-if-cached: 클라이언트는 캐시에 들어있는 사본만을 원한다.

### 7.9.7 주의할 점

## 7.10 캐시 제어 설정

### 7.10.1 아파치로 HTTP 헤더 제어하기

### 7.10.2 HTTP-EQUIV를 통한 HTML 캐시 제어

## 7.11 자세한 알고리즘

### 7.11.1 나이와 신선도 수명

### 7.11.2 나이 계산

### 7.11.3 완전한 나이 계산 알고리즘

### 7.11.4 신선도 수명 계산

### 7.11.5 완전한 서버 신선도 알고리즘

## 7.12 캐시와 광고

### 7.12.1 광고 회사의 딜레마

### 7.12.2 퍼블리셔의 응답

### 캐시 무력화

### 7.12.3 로그 마이그레이션

### 7.12.4 적중 측정과 사용량 제한

### 7.13 추가 정보
