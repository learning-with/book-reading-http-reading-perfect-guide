# 4. 커넥션 관리
## 4.1 TCP 커넥션
전 세계 모든 통신은 지그상의 컴퓨터와 네트워크 장비에서 널리 쓰이고 있는 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 통해 이뤄짐

세계 어디서든 클라이언트 애플리케이션은 서버 애플리케이션으로 TCP/IP 커넥션을 맺을 수 있으며, 일단 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받는 메시지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달됨
### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP
TCP는 HTTP에게 신뢰할 만한 통신 방식을 제공
### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다
TCP는 IP 패킷이라고 불리는 작은 조각을 통해 데이터를 전송

HTTP는 프로토콜 스택에서 최상위 계층이며, HTTP가 메시지를 전송하고자 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해서 메시지 데이터의 내용을 순서대로 보냄

TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고, 세그먼트를 IP 패킷에 담아서 인터넷을 통해 데이터를 전달
### 4.1.3 TCP 커넥션 유지하기
컴퓨터는 항상 TCP 커넥션을 여러개 가지고 있으며, TCP는 포트 번호를 통해서 여러 개의 커넥션을 유지
### 4.1.4 TCP 소켓 프로그래밍
## 4.2 TCP의 성능에 대한 고려
HTTP는 TCP 바로 위에 있는 계층이기 때문에 HTTP 트랜잭션의 성능은 TCP 성능에 영향을 받음
### 4.2.1 HTTP 트랜잭션 지연
### 4.2.2 성능 관련 중요 요소
### 4.2.3 TCP 커넥션 핸드셰이크 지연
### 4.2.4 확인응답 지연
### 4.2.5 TCP 느린 시작(slow start)
### 4.2.6 네이글(Nagle) 알고리즘과 TCP_NODELAY
### 4.2.7 TIME_WAIT의 누적과 포트 고갈
## 4.3 HTTP 커넥션 관리
### 4.3.1 흔히 잘못 이해하는 Connection 헤더
### 4.3.2 순차적인 트랜잭션 처리에 의한 지연
#### 병렬parallel 커넥션
여러 개의 TCP 커넥션을 통한 동시 HTTP 요청
#### 지속persistent 커넥션
커넥션을 맺고 끊는 데서 발생하는 지연을 제거하기 위한 TCP 커넥션의 재활용
#### 파이프라인pipelined 커넥션
공유 TCP 커넥션을 통한 병렬 HTTP 요청
#### 다중multiplexed 커넥션
요청과 응답들에 대한 중재
## 4.4 병렬 커넥션
### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다
### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다
### 4.4.3 병렬 커넥션은 더 빠르게 '느껴질 수' 있다
## 4.5 지속 커넥션
### 4.5.1 지속 커넥션 vs 병렬 커넥션
### 4.5.2 HTTP/1.0+의 Keep-Alive 커넥션
### 4.5.3 Keep-Alive 동작
### 4.5.4 Keep-Alive 옵션
### 4.5.5 Keep-Alive 커넥션 제한과 규칙
### 4.5.6 Keep-Alive와 멍청한(dumb) 프락시
#### Connection 헤더의 무조건 전달
#### 프락시와 홉별 헤더
### 4.5.7 Proxy-Connection 살펴보기
### 4.5.8 HTTP/1.1의 지속 커넥션
### 4.5.9 지속 커넥션의 제한과 규칙
- 클라이언트가 요청에 Connection: close 헤더를 포함해 보냈으면, 클라이언트는 그 커넥션으로 추가적인 요청을 보낼 수 없다.
- 클라이언트가 해당 커넥션으로 추가적인 요청을 보내지 않을 것이라면, 마지막 요청에 Connection: close 헤더를 보내야 한다.
- 커넥션에 있는 모든 메시지가 자신의 길이 정보를 정확히 가지고 있을 때에만 커넥션을 지속시킬 수 있다.
- HTTP/1.1 프락시는 클라이언트와 서버 각각에 대해 별도의 지속 커넥션을 맺고 관리해야 한다.
- HTTP/1.1 프락시 서버는 클라이언트가 커넥션 관련 기능에 대한 클라이언트의 지원 범위를 알고 있지 않은 한 지속 커넥션을 맺으면 안 된다.
- 서버는 메시지를 전송하는 중간에 커넥션을 끊지 않을 것이고 커넥션을 끊기 전에 적어도 한 개의 요청에 대해 응답을 할 것이긴 하지만, HTTP/1.1 기기는 Connection 헤더의 값과는 상관없이 언제든지 커넥션을 끊을 수 있다.
- HTTP/1.1 애플리케이션은 중간에 끊어지는 커넥션을 복구할 수 있어야만 한다. 클라이언트는 다시 보내도 문제가 없는 요청이라면 가능한 한 다시 보내야 한다.
- 클라이언트는 전체 응답을 받기 전에 커넥션이 끊어지면, 요청을 반복해서 보내도 문제가 없는 경우에는 요청을 다시 보낼 준비가 되어 있어야 한다.
- 하나의 사용자 클라이언트는 서버의 과부하를 방지하기 위해서, 넉넉잡아 두 개의 지속 커넥션만을 유지해ㅑ 한다. 따라서 N명의 사용자가 서버로 접근하려 한다면, 프락시는 서버나 상위 프락시에 넉넉잡아 약 2N개의 커넥션을 유지해야 한다.
## 4.6 파이프라인 커넥션
## 4.7 커넥션 끊기에 대한 미스터리
### 4.7.1 '마음대로' 커넥션 끊기
### 4.7.2 Content-Length와 Truncation
### 4.7.3 커넥션 끊기의 허용, 재시도, 멱등성
커넥션은 언제든 끊을 수 있음

한 번 혹은 여러 번 실행됐는지에 상관없이 같은 결과를 반환한다면 그 트랜잭션은 멱등idempotent하다고 함
### 4.7.4 우아한 커넥션 끊기
#### 전체 끊기와 절반 끊기
#### TCP 끊기와 리셋 에러
#### 우아하게 커넥션 끊기
## 4.8 추가 정보
### 4.8.1 HTTP 커넥션 관련 참고자료
### 4.8.2 HTTP 성능 이슈 관련 참고자료
### 4.8.3 TCP/IP 관련 참고자료
