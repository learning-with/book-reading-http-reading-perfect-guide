# 4장 커넥션 관리

## 4.1 TCP 커넥션

HTTP 통신은 TCP/IP를 통해 이루어진다.

TCP의 특징: 일단 커넥션이 맺어지면 메시지들이 손실, 손상, 순서가 바뀜이 없이 안전하게 전달됨

### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

HTTP 커넥션은 몇몇 사용 규칙 제외하면 TCP 커넥션. 신뢰할만한 통신 방식 제공. 순서에 맞게 전달

### 4.2.1 TCP 스트림은 세그먼트로 나뉘어 IP패킷을 통해 전송된다

TCP는 IP패킷(IP 데이터그램)이라는 작은 조각을 통해 데이터를 전송.

HTTP가 메시지를 전송할 떄.

1. TCP 커넥션을 통해서 메시지 데이터의 내용을 순서대로 보낸다.
2. TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나눈다
3. 세그먼트를 IP패킷이라고 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달한다.

IP패킷에 포함된 것

- IP 패킷 헤더
- TCP 세그먼트 헤더
- TCP 데이터 조각

### 4.1.3 TCP 커넥션 유지하기

컴퓨터는 TCP 커넥션을 여러개 가지고 있음. TCP는 포트 번호를 통해서 여러 커넥션을 유지

TCP 커넥션
<발신지 IP주소, 발신지 포트, 수신지 IP주소, 수신지 포트>

## 4.2 TCP의 성능에 대한 고려

HTTP 트랜잭션의 선능은 TCP 성능에 영향을 받는다.

### 4.2.1 HTTP 트랜잭션 지연

대부분의 HTTP지연은 TCP 네트워크 지연 떄문에 발생
HTTP 트랜잭션은 TCP 커넥션 설정, 요청 전송, 응답메시지를 보내는 것에 비하면 상당히 짧음.

HTTP 트랜잭션 지연 원인

1. DNS인프라 사용 시간
2. TCP 요청과 허가 응답
3. 요청 메시지가 서버에 의해서 처리되는 시간
4. 응답 보내느 시간

### 4.2.2 성능 관련 중요 요소

### 4.2.3 TCP 커넥션 핸드셰이크 지연

TCP 커넥션 핸드셰이크

1. 클 -> 서버 SYN
2. 서버 -> 클 SYN+ACK
3. 클 -> 서버 ACK

### 4.2.4 확인 응답 지연

확인응답: 데이터 전송이 성공적으로 진행되었따는 걸 보장해주기 위한 패킷으로 송신자에게 반환. 크기가 작아 데이터 패킷에 편승 시킨다. 그러면 편승시킬 데이터를 찾지 못하면 별도 패킷을 만들어 전송.

HTTP 동작방식은 편승할 기회가 많지 않아서 확인 응답 지연이 자주 발생.

### 4.2.5 TCP 느린 시작

TCP 커넥션은 시간이 지나면서 자체적으로 튜닝 되어서 처음에는 커넥션의 최대 속도를 제한. 갑작스러운 부하와 혼잡을 방지하는데 사용된다.

### 4.2.6 네이글 알고리즘과 TCP_NODELAY

TCP 세그먼트는 40바이트 상당의 헤더를 포함하기 때문에 아주 작은 크기의 데이터를 전송하면 오버헤드로 인한 부하가 증가할 수 있다

nagle algorithm 은 세그먼트가 ack 를 수신하거나 혹은 충분한 크기가 되기 전까지 전송하지 않고 데이터를 쌓아두었다가 전송한다

### 4.2.7 TIME_WAIT의 누적과 포트 고갈

TCP 커넥션이 종료된 후 곧바로 같은 IP adress 와 port 를 사용하는 커넥션이 생성될 경우 뒤늦게 도착한 이전 커넥션의 패킷이 존재할 경우 데이터 충돌이 발생할 수 있다

커넥션이 종료된 후, 이전 커넥션의 IP adress 와 port 를 TCP control block 에 저장해놓는다

일반적으로 2MSL (Max Segment Lifetime - 약 1분)동안 생성되지 않게 유지

## 4.3 HTTP 커넥션 관리

- HTTP 커넥션 헤더
- HTTP 커넥션의 최적화 기술

### 4.3.1 흔히 잘못 이해하는 Connection 헤더

Connection 헤더에 있는 세종류의 토큰

- HTTP 헤더 필드명 : 이 커넥션에만 해당되는 헤더들을 나열
- 임시적인 토큰 값 : 커넥션에 대한 비표준 옵션
- close 값은, 커넥션이 작업이 완료되면 종료되어야 함을 의미한다.

홉별(hop by hop) 헤더를 기술하는데 헤더 보호하기라고 한다. -> 다른 커넥션으로 전달되는 것을 막기 위함.

### 4.3.2 순차적인 트랙잭션 처리에 의한 지연

커넥션 관리는 TCP 성능에 영향을 준다.

HTTP 트랜잭션마다 새로운 커넥션을 맺으려고 하면 지연이 생길 것이다.

- 커넥션 맺는데 발생하는 지연
- 느린 시작 지연

이런 HTTP 커넥션의 성능을 향상 시킬 방법

1. 병렬 커넥션 2. 지속커넥션 3.파이프라인 커넥션 4. 다중 커넥션

## 4.4 병렬 커넥션

여러개의 TCP 커넥션을 통한 동시 HTTP 요청

### 4.4.1 병렬커넥션은 페이지를 더 빠르게 내려받는다

클라이언트의 인터넷 대역폭을 한 개의 커넥션이 다 사용하는게 아니라면 나머지 대역폭을 이용해서 다른 객체들을 가져올 수 있다.

### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다

클라이언트의 네트워크 대역폭이 좁을 때는 대부분의 시간을 데이터를 받아오는게 아니라 데이터를 보내는데 더 많은 시간을 보냄. 실제로는 여러개의 커넥션을 생성하면서 생기는 부하 때문에 더 오래 걸릴수도 있다.
브라우저는 대부분 4개의 병렬 커넥션을 가지며 서버는 과도한 커넥션은 임읠 ㅗ끊을 수 있다.

### 4.4.3 병렬 커넥션은 더 빠르게 '느껴질 수'있다.

클라이언트 입장에서 눈으로 확인할 수 있기 때문에 심리적인 현상.

## 4.5 지속 커넥션

처리가 완료된 이후에도 계쏙 연결 상태로 있는 TCP커넥션

사이트 지역성: HTTP요청을 하기 시작한 애플리케이션은 웹페이지 내의 이미지등을 가져오기 위해서 같은 서버에 또 요청하게 되는 현상

HTTP/1.1을 지원하는 기기는 처리가 완료된 후에도 TCP커넥션을 유지하여 앞으로 있을 HTTP요청에 재사용할 수 있음

### 4.5.1 지속커넥션 vs 병렬커넥션

병렬 커넥션의 단점

- 트랙잭션마다 새로운 커넥션을 맺고 끊기 떄문에 시간과 대역폭이 소요됨
- TCP 느린 시작 때문에 성능이 떨어진다.
- 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있다.

지속 커넥션의 장점

- 커넥션을 맺기위한 사전 작업과 지연을 줄여준다.
- 튜닝된 커넥션을 유지

지속 커넥션의 단점

- 잘못 사용하면 계속 연결된 상태로 있는 수많은 커넥션이 쌓이게된다.

지속 커넥션과 병렬 커넥션을 함꼐 사용하는게 효과적

### 4.5.2 HTTP/1.0+의 keep-Alive 커넥션

### 4.5.3 Keep-Alive 동작

1. 클라이언트 -> 서버) 커넥션 유지위해 Connection: Keep-Alive 헤더 포함
2. 서버 -> 클라이언트) 이 커넥션을 유지하고자 한다면 응답메세지에 같은 헤더 포함.

### 4.5.4 Keep-Alive 옵션

Keep-Alive 헤더를 주고받았다고 하더라도 언제든지 커넥션을 끊을 수 있다.
동작은 쉼표로 구분된 옵션들로 제어가능
timeout: 얼마간 유지될 것인지
max: 최대 몇개의 트랙잭션을 처리할 떄까지 유지될 것인지를 의미.

### 4.5.5 Keep-Alive 커넥션 제한과 규칙

Connection : Keep-Alive 헤더가 없으면 사용되지 않는다 (default 가 아님)

사용하려면 모든 HTTP 메세지에 Connection : Keep-Alive 헤더가 포함되야 한다

응답 헤더의 Connection : Keep-Alive 여부를 통해 커넥션이 끊어질 지 판단할 수 있다

정확한 Content-Length 값과 멀티파드 미디어 형식, 또는 chunked transfer encoding 으로 인코드 되어야 한다

연결이 지속되기 때문에 이전 메세지와 새로운 메세지의 경계를 정확히 알 수 있어야 하기 때문이다

프록시와 게이트웨이는 Connection 헤더 규칙을 철저히 지켜야 한다

메시지를 전달하거나 캐시에 넣기 전에 Connection 헤더와 관련된 모든 필드를 제거해야 한다

중개 서버에 Connection 헤더를 인식하지 못하는 프록시가 있다면 사용해선 안된다

HTTP/1.0 을 따르는 기기로부터 받는 모든 Connection 헤더 필드는 무시해야 한다

오래된 프록시 서버로부터 잘못 포함된 헤더가 있을 수 있다

클라이언트는 전체 응답을 다 받기 전에 커넥션이 끊어졌을 경우 다시 요청을 보낼 수 있어야 한다

### 4.5.6 Keep-Alive와 멍청한 프락시

프락시는 Connection 헤더를 이해하지 못하고 클라이언트와 서버 사이를 중개한다.
Connection : Keep-Alive 헤더를 잘 받은 서버와 클라이언트는 커넥션이 유지됨을 알고 있다.

하지만, 프락시는 이를 이해하지 못하고 한 번의 요청을 처리한 후에 서버와 커넥션이 끊어지길 기다린다. 그리고 클라이언트로부터 이후에 들어오는 요청에 대해서는 처리하지 못한다.

결국에는 브라우저는 서버가 타임아웃이 나서 커넥션이 끊길 때 까지 기다려야한다.

#### 해결방안

프락시는 Connection 헤더와 Connection 헤더에 명시된 헤더들은 절대 전달하면 안된다.

Proxy-Authenticate, Proxy-Connection, Transfer-Encoding, Upgrade 와 같은 헤더들도 홉별 헤더에 포함

### 4.5.7 Proxy-Connection

Connection 헤더 대신 비표준 헤더인 Proxy-Connection 을 대신 사용함으로써 문제를 회피하고자 함.

멍청한 프락시는 Proxy-Connection을 무시하고 서버에 전달하지만 서버는 Proxy-Connection 헤더는 무시하고 Connection 헤더만 처리하며,

영리한 프락시는 Proxy-Connection 을 Connection 헤더로 바꿔 서버로 전송한다

### 4.5.8 HTTP/1.1의 지속커넥션

HTTP/1.1은 keep-alive 지원X 설계가 개선된 지속 커넥션 지원.

HTTP/1.1은 별도의 설정을 하지 않는 한 모든 커넥션을 지속 커넥션으로 취급
HTTP/1.1 애플리케이션은 트랙잭션이 끝난 다음 커넥션을 끊으려면 Connection:close 헤더를 명시

### 4.5.9 지속 커넥션의 제한과 규칙

클라이언트가 Connection : close 헤더를 포함한 요청을 보낸 뒤에는 추가 요청이 불가능하다

추가 요청이 없다면 마지막 요청에 Connection : close 헤더를 포함시켜야 한다

커넥션의 모든 메세지가 자신의 정확한 길이 정보를 포함하고 있을 때만 가능하다

HTTP/1.1 프록시는 클라이언트와 서버 각각에 대해 별도의 지속 커넥션을 관리해야 한다

HTTP/1.1 프록시 서버은 클라이언트가 지원 가능한 커넥션 관련 기능에 대해 알지 못하는 경우 지속 커넥션을 맺으면 안된다

HTTP/1.1 어플리케이션은 중간에 끊어지는 커넥션을 복구할 수 있어야 한다

커넥션이 끊어졌을 때 클라이언트는 반복 요청에 대한 문제가 없는 경우 요청 재전송이 가능해야 한다

하나의 클라이언트 당 2개 이하의 지속 커넥션을 유지해야 한다

## 4.6 파이프 커넥션

HTTP/1.1은 지속커넥션을 통해 파이프라이닝 할 수 있음.

여러개의 요청이 오면 응답이 도착하기 전까지 큐에 쌓임. -> 왕복으로 인한 시간 줄여줌

#### 파이프라인 커넥션의 제약사항

HTTP 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전까지 파이프라인을 이으면 안된다

HTTP 응답순서는 요청 순서와 같아야 한다

HTTP 클라이언트는 예상치 못하게 끊어진 커넥션을 다시 맺고 요청을 보낼 준비가 되어야 한다

멱등하지 않은 메서드 요청은 파이프라인을 통해 보내면 안된다

- 클라이언트는 에러 발생 시 어떤 요청들이 이미 처리되었는지 알 수 가없다

## 4.7 커넥션 끊기에 대한 미스터리

커넥션 관리에는 명확한 기준X .

### 4.7.1 마음대로 커넥션 끊기

보통 커넥션은 메시지를 다 보낸 다음 끊지만 에러가 있는 상황에서는 엉뚱한 곳에서 끊길 수도.

서버는 일정시간동안 요청이 오지 않으면 커넥션을 끊을 수 있음 -> 클라이언트가 요청 메세지를 보내는 도중일 수도 있음 문제발생

### 4.7.2 Content-Length 와 Truncation

Content-Length: 본문의 정확한 크기 값을 가지는 헤더
수신자는 전달된 엔터티의 길이와 Content-Length의 값이 일치하지 않거나 존재하지 않으면 데이터의 정확한 길이를 서버에게 물어봐야함.

수신자가 캐시 프락시라면 이를 캐시하면 안된다.

### 4.7.3 커넥션 끊기의 허용 , 재시도, 멱등성

클라이언트는 트랙잭션을 재시도 하더라도 문제가 없다면 커넥션을 다시 맺고 한 번 더 전송해야한다.
파이프라인의 경우 클라이언트는 요청을 큐에 쌓아놓을 수 있다.

커넥션은 언제든 끊어질 수 있기 때문에 HTTP 어플리케이션은 그 시점에 적절히 대응할 준비가 되있어야 한다

클라이언트 입장에서는 응답이 오기 전에 커넥션이 끊기면 서버에서 얼마나 처리되었는지 알 수가 없다

non-idempotnet 한 요청들의 경우 반복 시 어떤 부작용이 일어날지 모름

이러한 요청들은 자동으로 재시도하면 안된다

### 4.7.4 우아한 커넥션 끊기

TCP커넥션은 양방향 커넥션

TCP 커넥션의 양쪽에는 각각의 입/출력 큐가 존재한다

어플리케이션은 TCP 커넥션의 입/출력 채널을 선택적으로 끊을 수 있다

- close() : 입력과 출력채널 모두를 끊는다

- shoutdown() : 입력, 출력 채널 중 하나를 끊는다

#### TCP 끊기와 리셋 에러

예상치 못한 쓰기 에러를 예방하기 위해 절반 끊기를 사용해야 한다

일반적으로 출력 채널을 끊는 것이 안전하다

클라이언트로부터 더 이상 요청이 오지 않을 것임을 확신하지 못하는 이상 입력 채널을 끊는 것은 위험하다

클라이언트 입장에서 connection reset by peer 메세지를 받을 경우 운영체제는 버퍼의 읽히지 않는 데이터를 모두 삭제할 수 있다

#### 우아하게 커넥션 끊기

출력 채널을 먼저 닫고 반대편 출력 채널이 끊기는 것을 기다린다

서로가 절반 끊기를 구현하고 있다는 보장이 없고, 우아한 커넥션 끊기 프로세스를 따른다는 보장도 없다

출력 채널을 닫은 뒤에도 입력 채널에 대한 상태 검사를 주기적으로 해야 함
